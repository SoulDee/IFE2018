## transform基本方法与matrix进阶

### transform基本方法
```
rotate( xx deg ) // 旋转，正值顺时针，负值逆时针
translate( x px, x px) // 正值相对左边的x轴位移，相对顶部的y轴位移，负值反之
scale( x , y) // 0 < x < 1 缩小，x > 1 放大,宽度高度的放大缩小
skew( xx deg ,xx deg ) // 倾斜，X轴正值左上角往左边拉，y轴正值左上角往上拉

//还有一点要注意，多个属性变换的时候，顺序是有影响的

// 原点，也就是参考点，旋转的旋转中心，放大缩小的参考点。默认中点50%，50%.
transform-origin: center;
```

### 高级方法

为什么是高级方法？因为不仅以上几个方法就是基于这个方法，而且这个方法还能实现复杂变化，例如镜像翻转。(在这个方法里单位省略)

矩阵神马的高中学过了不讲，以下是矩阵算值的原理：

![](http://image.zhangxinxu.com/image/blog/201206/2012-06-07_160412.png)

左边这个就是`transform: matrix(a,b,c,d,e,f)`的三阶矩阵等效写法，中间按照我的理解就是将一块面积分解为等大块，而xy则是指每一块。右边则是最终得到的值，然后通过得到的值对每一块进行变换。

以下是总结，具体的公式验算看参考的博客：
```
matrix(1, 0, 0, 1, 30, 30);
// 等效于(位移只和5、6的值有关)
translate( 30px, 30px );

matrix(3, 0, 0, 3, 0, 0);
// 等效于(比例和1、4的值有关)
scale(3, 3);

matrix(cos30,sin30,-sin30,cos30,0,0);
// 等效于 x'  = 1、3值和， y' = 2、4值和
rotate(30deg);

matrix(1,tan(30),tan(30),1,0,0);
// 等效于 (x轴同2值。y轴同3值有关)
skew(30deg，30deg);
```

### 高级方法的运用

以下个人的理解，可能存在错误，欢迎指出：

上面提到的是四个方法的matrix实现，那么如果我们要实现自己定义的复杂的变换呢？那么你需要做的是将你的变化找出规律（就跟高中解函数差不多），然后整合成矩阵公式的形式。接着就可以将a、b、c、d填入matrix方法中，（e、f只涉及x，y的平移，可不考虑）
```
// x' , y' 为变换之后的位置，x、y为变化前的。
x' = ax+cy+e;
y' = bx+dy+f;
```

以镜像翻转为例，高中知识讲到,翻转前后两个点的关系为：两个点都在一条垂直于对称轴的线，并且两个点的中点是在对称轴上的点。可以得到如下的两个公式：

```
// 两点的线同对称轴垂直
( y - y' ) / ( x - x' ) = -1 / k
// 两点中点可以代入对称轴
(  (x+x') / 2  )* k = ( y + y' ) / 2
```
之后按照上面所说的提取出x' , y'，代入matrix公式中就可以得到abcd的值了。3D变换的区别则是变成四阶矩阵，复杂度增加，但是本质的方向没变。

参考:

[CSS3 2D 转换](http://www.w3school.com.cn/css3/css3_2dtransform.asp)

[理解CSS3 transform中的Matrix(矩阵)](http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/)
